# 백준 1463번 - 1로 만들기

https://www.acmicpc.net/problem/1463


## 문제
정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.


정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

## 입력
첫째 줄에 1보다 크거나 같고, 10^6보다 작거나 같은 정수 N이 주어진다.

## 출력
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

### 예제 입력 1)
2

### 예제 출력 1)
1

### 예제 입력 2)
10

### 예제 출력 2)
3


## 내 풀이
`n+1` 길이의 배열 a 를 생성한다.

배열 `a`의 `i`번째 요소 `a[i]`는 `i`에서 1로 만드는데 걸리는 최소 연산 횟수를 뜻한다.
따라서 `a[1] = 0`으로 초기화한다.

이후, `i = 2` 부터 `n`까지 `a[i]`를 업데이트 한다.

1. `i % 3 == 0`인 경우
2. `i % 2 == 0`인 경우
3. `i`에서 1을 빼는 경우

위 3가지 경우 중에서 연산 횟수가 최소인 경우를 찾고, 그 값을 `a[i]`에 대입하면 된다. 마지막 `a[n]`까지 구한 후, `a[n]`을 출력하면 문제를 해결할 수 있다.

- 1번의 경우, `i`가 3으로 나누어 떨어지기 때문에 `i`의 연산 횟수는 <`i/3`의 연산 횟수 + 1>과 같다.
- 2번의 경우, `i`가 2로 나누어 떨어지기 때문에 `i`의 연산 횟수는 <`i/2`의 연산 횟수 + 1>과 같다.
- 3번의 경우, 단지 `i`의 값을 1 빼기 때문에 `i`의 연산 횟수는 <`i-1`의 연산 횟수 + 1>과 같다.

이를 코드로 구현하면 다음과 같다.

```java
// n+1 길이의 배열을 생성한다.
// a의 각 원소 a[i]는 수 i에 대한 연산의 최소 횟수이다.
int[] a = new int[n+1];
// 숫자 1의 연산 횟수는 0이기 때문에 a[1] = 0으로 초기화한다.
a[1] = 0;

// 숫자 2부터 반복한다.
for (int i = 2; i <= n; i++) {
    // i에 대한 연산의 최소값을 구한다.
    // 1을 빼는 연산은 i가 나뉘어지지 않으면 무조건 발생하기 때문에 먼저 구하여 min값으로 둔다.
    int min = a[i-1] + 1;
    // i가 3으로 나뉘어 떨어지면, i를 3으로 나눈 값의 연산 횟수 + 1 or 1을 빼는 연산의 수 중 최소값을 구한다.
    if (i % 3 == 0) {
        min = Math.min(min, a[i/3] + 1);
    }
    // i가 2로 나뉘어 떨어지면, i를 2로 나눈 값의 연산 횟수 + 1 or 직전에 구한 min값 중 최소값을 구한다.
    if (i % 2 == 0) {
        min = Math.min(min, a[i/2] + 1);
    }
    // 구한 최소값을 a[i]에 넣는다.
    a[i] = min;
}

// n의 연산 횟수인 a[n]을 출력한다.
System.out.println(a[n]);
```

