# Algorithm
알고리즘이란 문제를 해결하기 위한 것으로, 명확하게 정의되고 순서가 있는 유한 개의 규칙으로 이루어진 집합으로 정의할 수 있다.

1. 같은 답을 얻는 알고리즘은 하나가 아니다.
2. 빠른 알고리즘은 메모리를 많이 요구한다.

알고리즘의 성능을 객관적으로 평가하는 기준을 복잡도라고 한다. 복잡도는 두가지 요소를 가진다.

1. 시간 복잡도 : 실행에 필요한 시간을 평가한 것.
2. 공간 복잡도 : 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것.

알고리즘을 선택할 때 시간, 공간 복잡도의 균형을 생각할 필요성이 있다. 
알고리즘에서 시간 복잡도는 주어진 문제를 해결하기 위한 연산 횟수를 말한다. 일반적으로 1억 번의 연산을 1초의 시간으로 간주하여 예측한다.
복잡도의 대소관계는 다음과 같다.

- `O(1)` < `O(log n)` < `O(n)` < `O(n log n)` < `O(n^2)` < `O(n^k)` < `O(2^n)`

연산 횟수의 계산은 알고리즘의 시간 복잡도에 데이터의 크기를 대입하여 계산할 수 있다.

시간 복잡도의 도출 기준은 다음과 같다.

- 상수는 시간 복잡도 계산에서 제외.
- 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.

알고리즘 문제룰 풀 때, 다음과 같은 과정으로 문제를 푼다면 효율적일 듯 하다.

1. 문제 분석하기
2. 손으로 풀어보기
3. 슈도코드 작성
4. 코드 구현

위 과정을 통해 문제를 푸는 습관을 들이자. 문제를 보고 어떤 알고리즘을 사용하는 것이 좋을지 정하고, 손으로 그림, 슈도코드를 작성하면서 생각을 정리한 후, 코드를 구현하면 코드 구현단계에서 낭비하는 시간을 줄일 수 있을 듯 하다.


## 자료구조
### 배열
배열은 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조이다. 배열의 값은 인덱스를 통해 참조할 수 있고 선언한 자료형의 값만 저장할 수 있다. 배열의 특징은 다음과 같다.

- 인덱스를 사용하여 값에 바로 접근 가능.
- 새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어렵다. 삽입, 삭제를 원하는 값의 인덱스 주변에 있는 값을 이동시켜야 한다.
- 배열의 크기는 선언할 때 지정하고, 이후 수정이 불가하다.
- 구조가 간단하다.

### 리스트
리스트는 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조이다. C 언어의 연결 리스트로 생각하면 된다. 리스트의 특징은 다음과 같다.

- 인덱스가 없다. 값에 접근하기 위해서는 Head 포인터부터 차례로 접근해야 한다. 따라서 속도가 느리다.
- 포인터로 연결되어 있기 때문에 데이터의 삽입, 삭제 속도가 빠르다.
- 리스트의 크기는 정해져 있지 않다. 크기가 변하기 쉬운 데이터를 다룰 때 적절하다.
- 포인터를 저장할 공간이 필요하여 구조가 복잡하다.

### 덱
덱은 양 끝에서 데이터를 삽입하거나 삭제할 수 있는 자료구조이다.

- 덱의 맨 앞부분을 front, 맨 뒷부분을 last라고 한다.
- front 부분에 데이터를 삽입할 때는 `addFirst()`, 삭제할 때에는 `removeFirst()`를 이용한다.
- last 부분에 데이터를 삽입할 때에는 `addLast()`, 삭제할 때에는 `removeLast()`를 이용한다.
- 덱에서는 (index, value) 형태의 노드를 클래스로 구현하여 저장한다.

### 스택
스택은 삽입과 삭제 연산이 후입선출(LIFO)로 이루어지는 자료구조이다.

- 삽입과 삭제가 한 쪽에서만 일어난다. 연산이 일어나는 위치를 `top`이라고 한다.
- `push` : top 위치에 새로운 데이터를 삽입한다.
- `pop` : top 위치에 있는 현재 데이터를 삭제하고 확인한다.
- `peek` : top 위치에 현재 있는 데이터를 확인만 한다.

스택은 **깊이 우선 탐색(DFS)**과 **백트래킹 종류**의 코딩 테스트에 효과적이다. LIFO의 개념 자체가 재귀 함수 알고리즘 원리와 같기 때문이다.

### 큐
큐는 삽입과 삭제 연산이 선입선출(FIFO)로 이루어지는 자료구조이다.

- 삽입과 삭제가 양방향에서 이루어진다. 새로운 값을 삽입하는 쪽을 `rear`, 기존 데이터를 꺼내는 쪽을 `front`라고 한다.
- `add` 연산을 통해 `rear` 부분에 데이터를 추가한다.
- `poll` 연산을 통해 `front` 부분에 있는 데이터를 삭제하고 확인한다.
- `peek` 연산을 통해 큐의 `front` 부분에 있는 데이터를 단순 확인한다.

큐는 **너비 우선 탐색(BFS)**에서 자주 사용된다.

### 우선순위 큐
데이터가 삽입될 때 마다 어떠한 기준에 맞추어 리스트를 정렬한다.


## 알고리즘
### 구간 합
구간 합은 합 배열을 이용하여 시간 복잡도를 더 줄이기 위해 사용하는 특수한 목적의 알고리즘이다. 기존의 배열을 전처리한 배열로 생각할 수 있다. 이를 미리 구해두면 배열의 일정 범위의 합을 구하는 시간 복잡도가 `O(n)`에서 `O(1)`로 감소한다.

합 배열을 만드는 공식은 다음과 같다.

- `S[i] = S[i - 1] + A[i]`

합 배열에서 i에서 j까지의 구간 합을 구하는 공식은 다음과 같다.

- `S[j] - S[i - 1]` (단, j >= i)

#### 2차원 배열에서 구간 합
2차원 배열에서 구간 합 배열을 만드는 공식은 다음과 같다.

- `S[i][j] = S[i][j-1] + S[i-1][j] - S[i-1][j-1] + A[i][j]`

다음과 같은 2차원 배열이 있을 때, 위 공식을 이용하면 다음과 같은 구간 합 배열을 만들 수 있다.

1	2	3	4					1	3	6	10
2	3	4	5		->			3	8	15	24
3	4	5	6	(구간 합 배열)		6	15	27	42
4	5	6	7					10	24	42	64

위 구간 합 배열에서 [1, 3]의 값(6)은 [1, 1]에서 [1, 3]까지의 구간 합(1[1, 1] + 2[1, 2] + 3[1, 3])을 뜻한다.
구간 합 배열의 [2, 3]의 값(15)은 [1, 1]에서 [2, 3]까지의 구간 합(1, [1, 1] + 2[1, 2] + 3[1, 3] + 2[2, 1] + 3[2, 2] + 4[2, 3])을 말한다. 직선으로 연결되는 것이 아니라 해당 요소를 모서리로 하는 직사각형의 구간을 말한다고 볼 수 있다.

위의 2차원 배열에서 [2, 2], [3, 4]의 구간 합을 구하려면 구간 합 배열의 [2, 2] 요소와 [3, 4] 요소를 모서리로 하는 직사각형 구간의 합을 말한다. 따라서 구간 합 배열의 [3, 4] 요소에서 [3, 1] 요소의 값을 빼고, [1, 4] 요소의 값을 빼준다. 이렇게 값을 빼주면 구간 합 배열의 [1, 1]의 요소가 2번 빠졌기 때문에 이를 다시 더해주면 원하는 결과값이 나온다.
이에 대한 식은 다음과 같다.

- `result = S[x2][y2] - S[x2][y1 - 1] - S[x1 - 1][y2] + S[x1 - 1][y1 - 1]`


### 투 포인터
배열 등에서 2개의 포인터로 알고리즘의 시간 복잡도를 최적화하는 방법이다.

### 슬라이딩 윈도우
2개의 포인터로 범위를 지정한 다음, 범위를 유지한 채로 이동하며 문제를 해결하는 방법이다. 투 포인터 알고리즘과 매우 유사하다. 

### 정렬 알고리즘
- 버블 정렬 : 데이터의 인접 요소끼리 비교하여 swap 연산을 수행하며 정렬
- 선택 정렬 : 대상에서 가장 크거나 작은 데이터를 찾아 선택을 반복하면서 정렬
- 삽입 정렬 : 대상을 선택하여 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬
- 퀵 정렬 : pivot 값(기준값)을 선정하여 해당 값을 기준으로 정렬
- 병합 정렬 : 이미 정렬된 부분 집합들을 효율적으로 병합하여 전체를 정렬
- 기수 정렬 : 데이터의 자릿수를 바탕으로 비교하여 정렬

#### 버블 정렬
버블 정렬은 인접한 두 데이터의 크기를 비교하여 정렬한다. 구현이 간단하나 시간 복잡도는 `O(n^2)`로 비교적 느린 편이다. 루프를 돌면서 인접 데이터 간의 swap 연산으로 정렬한다. 
특정 루프에서 swap이 한번도 일어나지 않으면 이 후 값들은 모두 정렬된 것이므로 프로세스를 종료하여 연산 횟수를 줄일 수 있다.

	10 1 5 2 3
	1 5 2 3 10
	1 2 3 5 10
	1 2 3 5 10 <- swap이 일어나지 않음. 정렬 완료.

#### 선택 정렬
선택 정렬은 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법이다. 구현이 복잡하고 시간복잡도가 `O(n^2)`로 느린 편이다.
선택 정렬 알고리즘의 수행 방식은 다음과 같다.

1. 배열에서 최솟값(or 최대값)을 찾는다.
2. 해당 값을 배열의 가장 앞부분과 swap 한다.
3. swap된 위치를 범위에서 제외하고 남은 정렬 부분이 없을 때까지 반복한다.

#### 삽입 정렬
삽입 정렬은 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식이다. 시간 복잡도는 `O(n^2)`로 느리지만 구현이 쉽다.
삽입 정렬 알고리즘의 수행 방식은 다음과 같다.

1. index 1 -> size 만큼 진행
2. 현재 index의 데이터 선택
3. index 0 ~ (현재 index - 1) 까지, 즉 정렬된 범위 내에서 선택한 데이터가 삽입될 위치를 탐색한다.
4. 위치를 정하면 해당 위치부터 선택한 데이터의 index 까지 shift하여 데이터를 민다.
5. 삽입할 위치에 선택한 데이터를 삽입한다.
6. index++ -> 정렬된 범위 증가, 다음 데이터 선택. 2번으로 돌아가 반복한다.

3번 탐색 부분에서 이진 탐색 등과 같은 탐색 알고리즘을 사용하면 시간 복잡도를 줄일 수 있다.

#### 퀵 정렬
퀵 정렬은 기준값(pivot)을 선정하여 해당 값보다 작은 데이터와 큰 데이터로 분류 하는 것을 반복하여 정렬하는 알고리즘이다. 선정된 기준값에 따라 시간 복잡도에 영향을 미친다. 평균 시간복잡도는 `O(n log n)`이다.
퀵 정렬의 수행 과정은 다음과 같다.

1. 배열에서 start, end, pivot을 설정한다. start는 범위의 시작 인덱스, end는 끝 인덱스, pivot은 임의의 기준값이다.
2. pivot을 기준으로 start와 end의 값을 비교하여 그룹을 나눈다.
	1. a[start] < pivot -> start++;
	2. a[end] > pivot -> end—;
	3. a[start] > pivot && a[end] < pivot -> swap(a[start], a[end]), start++, end—;
	4. start >= end -> 반복 종료. (or start >= pivot || end <= pivot -> 반복 종료)
3. 분리된 집합에서 각각 위 과정을 반복한다.

퀵 정렬은 재귀 함수 형태로 구현된다.

#### 병합 정렬
병합 정렬은 분할 정복 방식을 사용하여 데이터를 분할하고 분할한 집합을 정렬하며 합치는 알고리즘이다. 시간 복잡도는 `O(n log n)`이다.
병합 정렬은 배열의 각각의 원소를 그룹으로 구분하고, 그룹을 2개씩 합쳐가며 정렬한다. 그룹을 합치고 정렬하는 과정을 반복하면 최종적으로 하나의 그룹이 되고 배열이 정렬된 것을 확인할 수 있다.
병합 정렬에서 두 개의 그룹을 병합할 때 투 포인터 개념을 이용하면 편리하다.

1. 두 개의 정렬된 그룹 각각에 index 포인터를 둔다. a[idx1], b[idx2] 라고 가정한다.
2. `min(a[idx1], b[idx2])`(또는 `max`) 를 통해 해당 값을 병합된 그룹을 저장할 배열 `c`에 저장한다.
3. 저장된 값의 그룹에 속하는 index 포인터를 증가시키고 2번 과정을 반복한다.
4. 한쪽 그룹의 index 포인터가 해당 그룹의 끝까지 완료되면 반대쪽 그룹의 값들을 c에 차례로 저장하고 반복을 종료한다. -> 그룹 병합 완료.

정렬할 그룹을 최소 길이로 나누고 이를 차례로 병합하면 정렬 효과를 볼 수 있다. 따라서 따로 swap 연산을 하지 않아도 된다.

	3 2 4 1
	(3, 2) -> c1 { 2 } -> c1 { 2, 3 }
	(4, 1) -> c2 { 1 } -> c2 { 1, 4 }
	c1, c2 병합 -> c3 { 1 } -> { 1, 2 } -> { 1, 2, 3 } -> { 1, 2, 3, 4 } -> 정렬 완료

#### 기수 정렬
기수 정렬은 값을 비교하지 않는다. 값을 놓고 비교할 자릿수를 정하여 해당 자릿수만을 비교한다. 기수 정렬은 0 ~ 9 까지의 자릿수의 값을 저장하는 10개의 큐를 이용한다. 

기수 정렬의 수행 과정은 다음과 같다.

1. 일의 자릿수를 기준으로 배열 원소를 큐에 넣는다. 큐는 0 ~ 9 까지 있다.
2. 0 ~ 9까지 순서대로 큐에서 데이터를 꺼낸다.
3. 자릿수를 하니씩 높여가며 마지막 자릿수를 기준으로 정렬할 때까지 반복한다.

기수 정렬은 시간 복잡도가 `O(kn)`으로 k는 데이터의 자릿수를 말한다. 기수 정렬은 시간 복잡도가 가장 짧은 정렬 알고리즘이다.
합 배열을 통해 기수 정렬의 큐 효과를 낼 수 있다.

1. 최대 자릿수 만큼 다음과정을 반복한다.
2. 자릿수별 숫자의 갯수를 담을 배열 a를 생성한다.
3. 값의 자릿수에 해당하는 a[index]를 1 증가시킨다. <- 정렬할 배열의 수만큼 반복
4. a 배열의 구간 합을 구한다. <- 이제 a 배열의 각 원소는 해당 자릿수에 맞는 값들이 정렬될 index를 의미한다.
5. 정렬할 배열의 각 원소를 배열 b(임시 정렬된 배열을 저장)에 저장한다. 정렬 대상 배열의 각 원소의 자릿값의 시작 index를 의미하는 a 배열의 값을 이용한다(`b[a[자릿값]`). 이후 `a[자릿값]`의 값을 1 감소시킨다.  <- 정렬할 배열의 끝에서부터 시작하여 정렬할 배열의 수만큼 반복한다.

14 13 22 3 24 30 31 11 33 23 21 20

0 = 2
1 = 3
2 = 1
3 = 4
4 = 2
2 5 6 10 12

i = 11 -> output[1] = a[11] -> output[1] = 20
i = 5 -> output[0] = a[5] -> output[0] = 30
30 20 31 11 21 22 13 3 33 23 14 24
// -> 수정하기.

### 탐색 알고리즘
탐색 알고리즘은 주어진 데이터에서 자신이 원하는 데이터를 찾아내는 알고리즘을 말한다. 주어진 데이터의 성질에 따라 적절한 알고리즘을 선택하는 것이 중요하다.

#### DFS - 깊이 우선 탐색
DFS는 **그래프 완전 탐색 기법** 중 하나이다. 그래프의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 최대 깊이까지 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 수행한다. DFS는 재귀 함수로 구현 가능하며 스택 자료구조의 개념을 이용한다. DFS의 시간 복잡도는 `O(V + E)`로 `V`는 노드의 수, `E`는 엣지의 수 이다.
DFS는 재귀 함수를 통해 구현하기 때문에 Stack Overflow에 유의해야 한다.
단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬 등의 문제에 이용된다.
DFS의 수행 과정은 다음과 같다.

1. DFS를 시작할 노드를 정한 후 사용할 자료구조를 초기화 한다. 그래프를 표현한 자료구조, 방문 배열, 스택 등을 초기화해야 한다.
2. 스택에서 노드를 꺼낸 후 노드의 인접 노드를 다시 스택에 삽입한다. 스택에 삽입할 때, 방문 배열도 체크한다.
3. 스택 자료구조에 값이 없을 때 까지 반복한다. 이미 방문 한 노드는 방문 배열을 바탕으로 재삽입하지 않는다.

#### BFS - 너비 우선 탐색
BFS는 그래프를 완전 탐색하는 방법 중 하나이다. 시작 노드에서 출발하여 이를 기준으로 가까운 노드를 먼저 방문하면서 탐색하는 알고리즘이다. BFS는 FIFO(선입선출) 방식으로 탐색하기 때문에 큐를 이용하여 구현한다. 또한 BFS는 탐색 시작 노드와 가까운 노드를 우선하여 탐색하기 때문에 목표 노드에 도착하는 경로가 여러 개일 때 최단 경로를 보장한다.

BFS의 수행 과정은 다음과 같다.

1. BFS 시작 노드를 정하고 사용할 자료구조를 초기화한다. 그래프를 표현한 자료구조, 방문한 노드를 체크하기 위한 배열, 큐를 초기화한다.
2. 큐에서 노드를 꺼낸 후, 꺼낸 노드의 인접 노드를 다시 큐에 삽입한다. 큐에 노드를 삽입할 때, 방문 배열도 체크한다.
3. 큐에 값이 없을 때까지 이를 반복한다. 이미 방문한 노드는 방문 배열을 바탕으로 재삽입하지 않는다.

#### 이진 탐색
이진 탐색은 데이터가 정렬되어 있는 상태에서 원하는 값을 찾아내는 알고리즘이다. 대상 데이터의 중앙값과 찾고자 하는 값을 비교하여 데이터의 크기를 절반씩 줄이면서 대상을 찾는다. 이진 탐색의 시간 복잡도는 `O(log N)`이다. 이진 탐색은 정렬 데이터에서 원하는 데이터를 탐색할 때 사용하는 가장 일반적인 알고리즘으로 구현 및 원리가 비교적 간단하다.

이진 탐색의 수행 과정은 다음과 같다.

0. 배열이 오름차순으로 정렬되어 있다고 가정한다.
1. 현재 데이터셋의 중앙값을 선택한다. 
2. 중앙값 > 타깃 일 때, 중앙값 기준으로 왼쪽 데이터셋을 선택한다.
3. 중앙값 < 타깃 이면, 중앙값 기준 오른쪽 데이터셋을 선택한다.
4. 중앙값 == 타깃이면 탐색을 종료한다.


### 그리디 알고리즘
그리디 알고리즘은 현재 상태에서 보는 선택지 중 최선의 선택지가 전체 선택지 중 최선의 선택지라고 가정하는 알고리즘이다. 현재 선택지 중에서 최선의 선택을 하고, 이를 반복하는 것이다. 그리디 알고리즘은 동적 계획법보다 구현하기가 쉽고 시간 복잡도가 우수하다. 하지만 항상 최적의 해을 보장하지 못한다는 단점이 있다. 그리디 알고리즘 적용을 위해 적용할 때의 논리 유무를 충분히 살펴야 한다.

그리디 알고리즘의 일반적인 수행 과정은 다음과 같다.

1. 해 선택 - 현재 상태에서 가장 최선이라고 생각되는 해를 선택한다.
2. 적절성 검사 - 현재 선택한 해가 전체 문제의 제약 조건에 벗어나지 않는지 검사한다.
3. 해 검사 - 현재까지 선택한 해 집합이 전체 문제를 해결할 수 있는지 검사한다. 전체 문제를 해결하지 못한다면 ①과정부터 다시 반복한다.

그리디 알고리즘을 적용하려면 다음 조건을 성립해야 한다.

- 그리디 알고리즘이 잘 작동하는 문제는 대부분 `greedy choice property`와 `optimal substructure`이라는 두가지 조건이 만족된다.
- `greedy choice property` - 탐욕적 선택 속성은 앞의 선택이 이후의 선택에 영향을 주지 않는다는 뜻이다.
- `optimal substructure` - 최적 부분 구조는 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다. 최종 최적해 == 부분 최적해 집합



### 정수론
#### 소수 구하기
소수는 1과 자기 자신만을 약수로 갖는 수(2 이상)를 말한다.
소수를 구하는 대표적인 판별법으로는 `에라토스테네스의 체`가 있다. `에라토스테네스의 체`의 시간복잡도는 일반적으로 `O(N log(log N))`이다. 배수를 삭제하는 연산으로 바깥쪽 for문을 생략하는 경우가 빈번하게 발생하기 때문이다.
해당 판별법의 핵심 원리는 다음과 같다.

1. 구하고자 하는 소수의 범위만큼 1차원 배열을 생성한다.
2. 1은 소수가 아니기 때문에 2부터 시작한다. `index`를 증가시키면서 현재 `index`의 배수를 배열의 끝까지 탐색하며 지운다. `index`는 지우지 않는다.
3. 배열의 끝까지 이를 반복하고 배열에 남아있는 모든 수를 출력한다. <- 소수.

```java
int n = 배열크기
boolean[] a = new boolean[n+1];

// 배열 초기화
for (int i = 2;i < n+1; i++) {
	a[i] = true;
}

// 2부터 시작.
for (int i = 2; i < n+1; i++) {
	// i가 지워지지 않았으면 수행
	if (a[i]) {
		for (int j = 2; j <= n/i; j++) {
			// i의 배수를 모두 지운다.
			if (a[i*j]) {
				a[i*j] = false;
			}
		}
	}
}
```


#### 오일러 P
오일러 P 함수 P[N]은 1부터 N까지의 범위에서 N과 서로소인 자연수의 개수를 말한다. 서로소는 1외에 공약수가 없는 수를 말한다. 오일러 P 함수의 원리는 다음과 같다.

> N의 가장 큰 소인수가 N의 제곱근보다 작다면, 모든 소인수는 N의 제곱근 보다 작다.
> 만약 가장 큰 소인수가 N의 제곱근 보다 크더라도, 두번째로 큰 소인수는 N의 제곱근 보다 작다.

- 1 부터 K 까지의 서로소 개수를 구하는 과정
	1. 구하고자 하는 오일러 P의 범위만큼 배열을 초기화한다.
	2. 2 부터 시작하여 현재 배열의 값과 인덱스가 같으면(소수이면) 현재 선택된 숫자 `K`의 배수에 해당하는 수를 배열에서 끝까지 탐색하여 `P[i] = P[i] - P[i] / K` 연산을 수행한다. 이 때, `i`는 `K`의 배수이다. 
		- `P[i] = P[i] - P[i] / K`는 `K`의 배수를 제외한 수의 개수로 업데이트 하는 연산이다. <- 오일러 P 공식
	3. 배열의 끝까지 2번 과정을 반복한다.

- `백준 11689` 문제 풀이
```java
public class BaekJoon11689 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // 자연수 n을 입력받는다.
        long n = Long.parseLong(br.readLine());
        // 결과값을 n으로 세팅.
        long result = n;

        // N의 가장 큰 소인수가 N의 제곱근보다 작다면, 모든 소인수는 N의 제곱근 보다 작다.
        // 만약 가장 큰 소인수가 N의 제곱근 보다 크더라도, 두번째로 큰 소인수는 N의 제곱근 보다 작다.

        // 2부터 1씩 늘려가며 n의 제곱근까지 수행한다.
        for (int i = 2; i <= Math.sqrt(n); i++) {
            // 자연수 n이 i를 약수로 가지면 if 내부 수행.
            if (n % i == 0) {
                // 오일러 P 공식 적용
                // result = result * (1 - 1/p) = result - result/p
                result -= result / i;
                while (n % i == 0) {
                    // 다음 소인수를 찾기 위해 i로 나누어 떨어질 때 까지 i로 나눈다.
                    n /= i;
                }
            }
        }

        // 아직 약수가 남아있다면
        if (n > 1) {
            // 오일러 공식을 한번 더 적용한다.
            result -= result / n;
        }

        System.out.println(result);
    }
}
```

#### 유클리드 호제법
유클리드 호제법은 두 수의 최대 공약수를 구하는 알고리즘이다. MOD 연산을 이용하여 최대공약수를 구한다.

1. 큰 수(M)를 작은 수(N)로 나누는 MOD 연산을 수행한다.
2. 1번의 작은 수(N)와 1번 MOD 연산 결과값으로 MOD 연산을 수행한다.
3. 나머지가 0이 될 때까지 1 2번을 반복하여 0이 되면 작은 수를 최대 공약수로 선택한다.

- 유클리드 호제법 구현
```java
public static int gcd(int a, int b) {
	if (b == 0) {
		return a;
	} esle {
		return gcd(b, a % b);
	}
}
```




#Algorithm